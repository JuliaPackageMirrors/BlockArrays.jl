{
    "docs": [
        {
            "location": "/", 
            "text": "BlockArrays.jl\n\n\nBlock arrays in Julia\n\n\n \n\n\nA block array is a partition of an array into blocks or subarrays, see \nwikipedia\n for a more extensive description. This package has two purposes. Firstly, it defines an interface for an \nAbstractBlockArray\n block arrays that can be shared among types representing different types of block arrays. The advantage to this is that it provides a consistent API for block arrays.\n\n\nSecondly, it also implements two different type of block arrays that follow the \nAbstractBlockArray\n interface. The type \nBlockArray\n stores each block contiguously while the type \nPseudoBlockArray\n stores the full matrix contiguously. This means that \nBlockArray\n supports fast non copying extraction and insertion of blocks while \nPseudoBlockArray\n supports fast access to the full matrix to use in in for example a linear solver.\n\n\nNote:\n Currently, a quite new build of julia master is needed to use this package.\n\n\n\n\nManual Outline\n\n\n\n\nThe AbstractBlockArray interface\n\n\nBlockArrays\n\n\nCreating uninitialized \nBlockArrays\n.\n\n\nSetting and getting blocks and values\n\n\nConverting between \nBlockArray\n and normal arrays\n\n\nOperations on \nBlockArrays\n.\n\n\n\n\n\n\nPseudoBlockArrays\n\n\nCreating PseudoBlockArrays\n\n\nSetting and getting blocks and values\n\n\n\n\n\n\n\n\n\n\nLibrary Outline\n\n\n\n\nPublic Documentation\n\n\nContents\n\n\nIndex\n\n\nAbstractBlockArray interface\n\n\nBlockArray\n\n\nPseudoBlockArray\n\n\n\n\n\n\nInternal Documentation\n\n\nContents\n\n\nIndex\n\n\nInternals\n\n\n\n\n\n\n\n\n\n\nIndex\n\n\n\n\nBase.full\n\n\nBase.getindex\n\n\nBase.setindex!\n\n\nBlockArrays.AbstractBlockArray\n\n\nBlockArrays.Block\n\n\nBlockArrays.BlockArray\n\n\nBlockArrays.BlockBoundsError\n\n\nBlockArrays.PseudoBlockArray\n\n\nBlockArrays.blockcheckbounds\n\n\nBlockArrays.blocksize\n\n\nBlockArrays.getblock\n\n\nBlockArrays.getblock!\n\n\nBlockArrays.nblocks\n\n\nBlockArrays.setblock!\n\n\nBlockArrays.BlockIndex\n\n\nBlockArrays.blockindex2global\n\n\nBlockArrays.global2blockindex", 
            "title": "Home"
        }, 
        {
            "location": "/#blockarraysjl", 
            "text": "Block arrays in Julia     A block array is a partition of an array into blocks or subarrays, see  wikipedia  for a more extensive description. This package has two purposes. Firstly, it defines an interface for an  AbstractBlockArray  block arrays that can be shared among types representing different types of block arrays. The advantage to this is that it provides a consistent API for block arrays.  Secondly, it also implements two different type of block arrays that follow the  AbstractBlockArray  interface. The type  BlockArray  stores each block contiguously while the type  PseudoBlockArray  stores the full matrix contiguously. This means that  BlockArray  supports fast non copying extraction and insertion of blocks while  PseudoBlockArray  supports fast access to the full matrix to use in in for example a linear solver.  Note:  Currently, a quite new build of julia master is needed to use this package.", 
            "title": "BlockArrays.jl"
        }, 
        {
            "location": "/#manual-outline", 
            "text": "The AbstractBlockArray interface  BlockArrays  Creating uninitialized  BlockArrays .  Setting and getting blocks and values  Converting between  BlockArray  and normal arrays  Operations on  BlockArrays .    PseudoBlockArrays  Creating PseudoBlockArrays  Setting and getting blocks and values", 
            "title": "Manual Outline"
        }, 
        {
            "location": "/#library-outline", 
            "text": "Public Documentation  Contents  Index  AbstractBlockArray interface  BlockArray  PseudoBlockArray    Internal Documentation  Contents  Index  Internals", 
            "title": "Library Outline"
        }, 
        {
            "location": "/#index", 
            "text": "Base.full  Base.getindex  Base.setindex!  BlockArrays.AbstractBlockArray  BlockArrays.Block  BlockArrays.BlockArray  BlockArrays.BlockBoundsError  BlockArrays.PseudoBlockArray  BlockArrays.blockcheckbounds  BlockArrays.blocksize  BlockArrays.getblock  BlockArrays.getblock!  BlockArrays.nblocks  BlockArrays.setblock!  BlockArrays.BlockIndex  BlockArrays.blockindex2global  BlockArrays.global2blockindex", 
            "title": "Index"
        }, 
        {
            "location": "/man/abstractblockarrayinterface/", 
            "text": "The AbstractBlockArray interface\n\n\nIn order to follow the \nAbstractBlockArray\n the following methods should be implemented:\n\n\n\n\n\n\n\n\nMethods to implement\n\n\nBrief description\n\n\n\n\n\n\n\n\n\n\nnblocks(A)\n\n\nTuple of number of blocks in each dimension\n\n\n\n\n\n\nnblocks(A, i)\n\n\nNumber of blocks in dimension \ni\n\n\n\n\n\n\nblocksize(A, i...)\n\n\nSize of the block at block index \ni...\n\n\n\n\n\n\ngetblock(A, i...)\n\n\nX[Block(i...)]\n, blocked indexing\n\n\n\n\n\n\nsetblock!(A, v, i...)\n\n\nX[Block(i...)] = v\n, blocked index assignment\n\n\n\n\n\n\nfull(A)\n\n\nThe non blocked array\n\n\n\n\n\n\nOptional methods\n\n\n\n\n\n\n\n\ngetblock!(x, A, i)\n\n\nX[i]\n, blocked index assignment with in place storage in \nx\n\n\n\n\n\n\n\n\nFor a more thorough description of the methods see the public interface documentation.\n\n\nWith the methods above implemented the following are automatically provided:\n\n\n\n\nA pretty printing \nshow\n function that uses unicode lines to split up the blocks:\n\n\n\n\njulia\n A = BlockArray(rand(4, 5), [1,3], [2,3])\n2\u00d72-blocked 4\u00d75 BlockArrays.BlockArray{Float64,2,Array{Float64,2}}:\n 0.28346   0.234328  \u2502  0.10266   0.0670817  0.941958\n --------------------\u253c-------------------------------\n 0.881618  0.152164  \u2502  0.938311  0.819992   0.860623\n 0.74367   0.16049   \u2502  0.704886  0.950269   0.601036\n 0.502035  0.259069  \u2502  0.857453  0.197673   0.962873\n\n\n\n\n\n\nIndexing with \nEnums\n works as a way to access blocks and set blocks.\n\n\n\n\njulia\n @enum vars u=1 v=2\n\njulia\n A[u, v]\n1\u00d73 Array{Float64,2}:\n 0.10266  0.0670817  0.941958\n\njulia\n A[u, v] = zeros(1,3);\n\njulia\n A[u, v]\n1\u00d73 Array{Float64,2}:\n 0.0  0.0  0.0\n\n\n\n\n\n\nA bounds index checking function for indexing with blocks:\n\n\n\n\njulia\n blockcheckbounds(A, 5, 3)\nERROR: BlockBoundsError: attempt to access 2\u00d72-blocked 4\u00d75 BlockArrays.BlockArray{Float64,2,Array{Float64,2}} at block index [5,3]\n in blockcheckbounds(::BlockArrays.BlockArray{Float64,2,Array{Float64,2}}, ::Int64, ::Int64) at .julia/v0.5/BlockArrays/src/abstractblockarray.jl:190\n in eval(::Module, ::Any) at ./boot.jl:226\n\n\n\n\n\n\nHappy users who know how to use your new block array :)", 
            "title": "AbstractBlockArray interface"
        }, 
        {
            "location": "/man/abstractblockarrayinterface/#the-abstractblockarray-interface", 
            "text": "In order to follow the  AbstractBlockArray  the following methods should be implemented:     Methods to implement  Brief description      nblocks(A)  Tuple of number of blocks in each dimension    nblocks(A, i)  Number of blocks in dimension  i    blocksize(A, i...)  Size of the block at block index  i...    getblock(A, i...)  X[Block(i...)] , blocked indexing    setblock!(A, v, i...)  X[Block(i...)] = v , blocked index assignment    full(A)  The non blocked array    Optional methods     getblock!(x, A, i)  X[i] , blocked index assignment with in place storage in  x     For a more thorough description of the methods see the public interface documentation.  With the methods above implemented the following are automatically provided:   A pretty printing  show  function that uses unicode lines to split up the blocks:   julia  A = BlockArray(rand(4, 5), [1,3], [2,3])\n2\u00d72-blocked 4\u00d75 BlockArrays.BlockArray{Float64,2,Array{Float64,2}}:\n 0.28346   0.234328  \u2502  0.10266   0.0670817  0.941958\n --------------------\u253c-------------------------------\n 0.881618  0.152164  \u2502  0.938311  0.819992   0.860623\n 0.74367   0.16049   \u2502  0.704886  0.950269   0.601036\n 0.502035  0.259069  \u2502  0.857453  0.197673   0.962873   Indexing with  Enums  works as a way to access blocks and set blocks.   julia  @enum vars u=1 v=2\n\njulia  A[u, v]\n1\u00d73 Array{Float64,2}:\n 0.10266  0.0670817  0.941958\n\njulia  A[u, v] = zeros(1,3);\n\njulia  A[u, v]\n1\u00d73 Array{Float64,2}:\n 0.0  0.0  0.0   A bounds index checking function for indexing with blocks:   julia  blockcheckbounds(A, 5, 3)\nERROR: BlockBoundsError: attempt to access 2\u00d72-blocked 4\u00d75 BlockArrays.BlockArray{Float64,2,Array{Float64,2}} at block index [5,3]\n in blockcheckbounds(::BlockArrays.BlockArray{Float64,2,Array{Float64,2}}, ::Int64, ::Int64) at .julia/v0.5/BlockArrays/src/abstractblockarray.jl:190\n in eval(::Module, ::Any) at ./boot.jl:226   Happy users who know how to use your new block array :)", 
            "title": "The AbstractBlockArray interface"
        }, 
        {
            "location": "/man/blockarrayss/", 
            "text": "BlockArrays\n\n\n\n\nCreating uninitialized \nBlockArrays\n.\n\n\nA \nBlockArray\n can be created with the blocks left uninitialized using the \nBlockArray(block_type, block_sizes...)\n function. The \nblock_type\n should be an array type, it could for example be \nMatrix{Float64}\n. The block sizes are each a \nVector{Int}\n which determines the size of the blocks in that dimension. We here create a \n[1,2]\u00d7[3,2]\n block matrix of \nFloat32\ns:\n\n\njulia\n BlockArray(Matrix{Float32}, [1,2], [3,2])\n2\u00d72-blocked 3\u00d75 BlockArrays.BlockArray{Float32,2,Array{Float32,2}}:\n #undef  #undef  #undef  \u2502  #undef  #undef\n ------------------------\u253c----------------\n #undef  #undef  #undef  \u2502  #undef  #undef\n #undef  #undef  #undef  \u2502  #undef  #undef\n\n\n\n\nWe can also use a \nSparseVector\n or any other user defined array type:\n\n\njulia\n BlockArray(SparseVector{Float64, Int}, [1,2])\n2-blocked 3-element BlockArrays.BlockArray{Float64,1,SparseVector{Float64,Int64}}:\n #undef\n ------\n #undef\n #undef\n\n\n\n\nNote that accessing an undefined block will throw an \"access to undefined reference\"-error.\n\n\n\n\nSetting and getting blocks and values\n\n\nA block can be set by \nsetblock!(block_array, v, i...)\n where \nv\n is the array to set and \ni\n is the block index. An alternative syntax for this is \nblock_array[Block(i...)] = v\n.\n\n\njulia\n block_array = BlockArray(Matrix{Float64}, [1,2], [2,2])\n2\u00d72-blocked 3\u00d74 BlockArrays.BlockArray{Float64,2,Array{Float64,2}}:\n #undef  #undef  \u2502  #undef  #undef\n ----------------\u253c----------------\n #undef  #undef  \u2502  #undef  #undef\n #undef  #undef  \u2502  #undef  #undef\n\njulia\n setblock!(block_array, rand(2,2), 2, 1)\n2\u00d72-blocked 3\u00d74 BlockArrays.BlockArray{Float64,2,Array{Float64,2}}:\n #undef      #undef      \u2502  #undef  #undef\n ------------------------\u253c----------------\n   0.314407    0.298761  \u2502  #undef  #undef\n   0.91585     0.644499  \u2502  #undef  #undef\n\njulia\n block_array[Block(1, 1)] = [1 2];\n\njulia\n block_array\n2\u00d72-blocked 3\u00d74 BlockArrays.BlockArray{Float64,2,Array{Float64,2}}:\n 1.0       2.0       \u2502  #undef  #undef\n --------------------\u253c----------------\n 0.314407  0.298761  \u2502  #undef  #undef\n 0.91585   0.644499  \u2502  #undef  #undef\n\n\n\n\nNote that this will \"take ownership\" of the passed in array, that is, no copy is made.\n\n\nA block can be retrieved with \ngetblock(block_array, i...)\n or \nblock_array[Block(i...)]\n:\n\n\njulia\n block_array[Block(1, 1)]\n1\u00d72 Array{Float64,2}:\n 1.0  2.0\n\n\n\n\nSimilarly to \nsetblock!\n this does not copy the returned array.\n\n\nFor setting and getting a single scalar element, the usual \nsetindex!\n and \ngetindex\n are available.\n\n\njulia\n block_array[1, 2]\n2.0\n\n\n\n\n\n\nConverting between \nBlockArray\n and normal arrays\n\n\nAn array can be repacked into a \nBlockArray\n with\nBlockArray(array, block_sizes...)\n:\n\n\njulia\n block_array_sparse = BlockArray(sprand(4, 5, 0.7), [1,3], [2,3])\n2\u00d72-blocked 4\u00d75 BlockArrays.BlockArray{Float64,2,SparseMatrixCSC{Float64,Int64}\n 0.0       0.284338  \u2502  0.0         0.52346   0.403969\n --------------------\u253c--------------------------------\n 0.909193  0.0       \u2502  0.0         0.3401    0.922003\n 0.0       0.736793  \u2502  0.00840872  0.804832  0.441806\n 0.0       0.0       \u2502  0.553519    0.757454  0.575238\n\n\n\n\nTo get back the full array use \nfull\n:\n\n\njulia\n full(block_array_sparse)\n4\u00d75 sparse matrix with 13 Float64 nonzero entries:\n    [2, 1]  =  0.909193\n    [1, 2]  =  0.284338\n      \u22ee\n    [3, 5]  =  0.441806\n    [4, 5]  =  0.575238\n\n\n\n\n\n\nOperations on \nBlockArrays\n.\n\n\nSimple unary/binary functions and reductions are available, for an overview, see the \noperations.jl\n file.", 
            "title": "BlockArrays"
        }, 
        {
            "location": "/man/blockarrayss/#blockarrays", 
            "text": "", 
            "title": "BlockArrays"
        }, 
        {
            "location": "/man/blockarrayss/#creating-uninitialized-blockarrays", 
            "text": "A  BlockArray  can be created with the blocks left uninitialized using the  BlockArray(block_type, block_sizes...)  function. The  block_type  should be an array type, it could for example be  Matrix{Float64} . The block sizes are each a  Vector{Int}  which determines the size of the blocks in that dimension. We here create a  [1,2]\u00d7[3,2]  block matrix of  Float32 s:  julia  BlockArray(Matrix{Float32}, [1,2], [3,2])\n2\u00d72-blocked 3\u00d75 BlockArrays.BlockArray{Float32,2,Array{Float32,2}}:\n #undef  #undef  #undef  \u2502  #undef  #undef\n ------------------------\u253c----------------\n #undef  #undef  #undef  \u2502  #undef  #undef\n #undef  #undef  #undef  \u2502  #undef  #undef  We can also use a  SparseVector  or any other user defined array type:  julia  BlockArray(SparseVector{Float64, Int}, [1,2])\n2-blocked 3-element BlockArrays.BlockArray{Float64,1,SparseVector{Float64,Int64}}:\n #undef\n ------\n #undef\n #undef  Note that accessing an undefined block will throw an \"access to undefined reference\"-error.", 
            "title": "Creating uninitialized BlockArrays."
        }, 
        {
            "location": "/man/blockarrayss/#setting-and-getting-blocks-and-values", 
            "text": "A block can be set by  setblock!(block_array, v, i...)  where  v  is the array to set and  i  is the block index. An alternative syntax for this is  block_array[Block(i...)] = v .  julia  block_array = BlockArray(Matrix{Float64}, [1,2], [2,2])\n2\u00d72-blocked 3\u00d74 BlockArrays.BlockArray{Float64,2,Array{Float64,2}}:\n #undef  #undef  \u2502  #undef  #undef\n ----------------\u253c----------------\n #undef  #undef  \u2502  #undef  #undef\n #undef  #undef  \u2502  #undef  #undef\n\njulia  setblock!(block_array, rand(2,2), 2, 1)\n2\u00d72-blocked 3\u00d74 BlockArrays.BlockArray{Float64,2,Array{Float64,2}}:\n #undef      #undef      \u2502  #undef  #undef\n ------------------------\u253c----------------\n   0.314407    0.298761  \u2502  #undef  #undef\n   0.91585     0.644499  \u2502  #undef  #undef\n\njulia  block_array[Block(1, 1)] = [1 2];\n\njulia  block_array\n2\u00d72-blocked 3\u00d74 BlockArrays.BlockArray{Float64,2,Array{Float64,2}}:\n 1.0       2.0       \u2502  #undef  #undef\n --------------------\u253c----------------\n 0.314407  0.298761  \u2502  #undef  #undef\n 0.91585   0.644499  \u2502  #undef  #undef  Note that this will \"take ownership\" of the passed in array, that is, no copy is made.  A block can be retrieved with  getblock(block_array, i...)  or  block_array[Block(i...)] :  julia  block_array[Block(1, 1)]\n1\u00d72 Array{Float64,2}:\n 1.0  2.0  Similarly to  setblock!  this does not copy the returned array.  For setting and getting a single scalar element, the usual  setindex!  and  getindex  are available.  julia  block_array[1, 2]\n2.0", 
            "title": "Setting and getting blocks and values"
        }, 
        {
            "location": "/man/blockarrayss/#converting-between-blockarray-and-normal-arrays", 
            "text": "An array can be repacked into a  BlockArray  with BlockArray(array, block_sizes...) :  julia  block_array_sparse = BlockArray(sprand(4, 5, 0.7), [1,3], [2,3])\n2\u00d72-blocked 4\u00d75 BlockArrays.BlockArray{Float64,2,SparseMatrixCSC{Float64,Int64}\n 0.0       0.284338  \u2502  0.0         0.52346   0.403969\n --------------------\u253c--------------------------------\n 0.909193  0.0       \u2502  0.0         0.3401    0.922003\n 0.0       0.736793  \u2502  0.00840872  0.804832  0.441806\n 0.0       0.0       \u2502  0.553519    0.757454  0.575238  To get back the full array use  full :  julia  full(block_array_sparse)\n4\u00d75 sparse matrix with 13 Float64 nonzero entries:\n    [2, 1]  =  0.909193\n    [1, 2]  =  0.284338\n      \u22ee\n    [3, 5]  =  0.441806\n    [4, 5]  =  0.575238", 
            "title": "Converting between BlockArray and normal arrays"
        }, 
        {
            "location": "/man/blockarrayss/#operations-on-blockarrays", 
            "text": "Simple unary/binary functions and reductions are available, for an overview, see the  operations.jl  file.", 
            "title": "Operations on BlockArrays."
        }, 
        {
            "location": "/man/pseudoblockarrays/", 
            "text": "PseudoBlockArrays\n\n\nA \nPseudoBlockArray\n is similar to a \nBlockArray\n except the full array is stored contiguously instead of block by block. This means that is not possible to insert and retrieve blocks without copying data. On the other hand \nfull\n on a \nPseudoBlockArray\n is instead instant since it just returns the wrapped array.\n\n\nWhen iteratively solving a set of equations with a gradient method the Jacobian typically has a block structure. It can be convenient to use a \nPseudoBlockArray\n to build up the Jacobian block by block and then pass the resulting matrix to a direct solver using \nfull\n.\n\n\n\n\nCreating PseudoBlockArrays\n\n\nCreating a \nPseudoBlockArray\n works in the same way as a \nBlockArray\n.\n\n\njulia\n pseudo = PseudoBlockArray(rand(3,3), [1,2], [2,1])\n2\u00d72-blocked 3\u00d73 BlockArrays.PseudoBlockArray{Float64,2,Array{Float64,2}}:\n 0.282059  0.560107  \u2502  0.540811\n --------------------\u253c----------\n 0.46358   0.11423   \u2502  0.520826\n 0.250737  0.809022  \u2502  0.905993\n\n\n\n\nThis \"takes ownership\" of the passed in array so no copy of the array is made.\n\n\n\n\nSetting and getting blocks and values\n\n\nSetting and getting blocks uses the same API as \nBlockArrays\n. The difference here is that setting a block will update the block in place and getting a block will extract a copy of the block and return it. For \nPseudoBlockArrays\n there is a mutating block getter called \ngetblock!\n which updates a passed in array to avoid a copy:\n\n\njulia\n A = zeros(2,2)\n\njulia\n getblock!(A, pseudo, 2, 1);\n\njulia\n A\n2\u00d72 Array{Float64,2}:\n 0.46358   0.11423\n 0.250737  0.809022\n\n\n\n\nThe underlying array is accessed with \nfull\n just like for \nBlockArray\n.", 
            "title": "PseudoBlockArrays"
        }, 
        {
            "location": "/man/pseudoblockarrays/#pseudoblockarrays", 
            "text": "A  PseudoBlockArray  is similar to a  BlockArray  except the full array is stored contiguously instead of block by block. This means that is not possible to insert and retrieve blocks without copying data. On the other hand  full  on a  PseudoBlockArray  is instead instant since it just returns the wrapped array.  When iteratively solving a set of equations with a gradient method the Jacobian typically has a block structure. It can be convenient to use a  PseudoBlockArray  to build up the Jacobian block by block and then pass the resulting matrix to a direct solver using  full .", 
            "title": "PseudoBlockArrays"
        }, 
        {
            "location": "/man/pseudoblockarrays/#creating-pseudoblockarrays", 
            "text": "Creating a  PseudoBlockArray  works in the same way as a  BlockArray .  julia  pseudo = PseudoBlockArray(rand(3,3), [1,2], [2,1])\n2\u00d72-blocked 3\u00d73 BlockArrays.PseudoBlockArray{Float64,2,Array{Float64,2}}:\n 0.282059  0.560107  \u2502  0.540811\n --------------------\u253c----------\n 0.46358   0.11423   \u2502  0.520826\n 0.250737  0.809022  \u2502  0.905993  This \"takes ownership\" of the passed in array so no copy of the array is made.", 
            "title": "Creating PseudoBlockArrays"
        }, 
        {
            "location": "/man/pseudoblockarrays/#setting-and-getting-blocks-and-values", 
            "text": "Setting and getting blocks uses the same API as  BlockArrays . The difference here is that setting a block will update the block in place and getting a block will extract a copy of the block and return it. For  PseudoBlockArrays  there is a mutating block getter called  getblock!  which updates a passed in array to avoid a copy:  julia  A = zeros(2,2)\n\njulia  getblock!(A, pseudo, 2, 1);\n\njulia  A\n2\u00d72 Array{Float64,2}:\n 0.46358   0.11423\n 0.250737  0.809022  The underlying array is accessed with  full  just like for  BlockArray .", 
            "title": "Setting and getting blocks and values"
        }, 
        {
            "location": "/lib/public/", 
            "text": "Public Documentation\n\n\nDocumentation for \nBlockArrays.jl\n's public interface.\n\n\nSee \nInternal Documentation\n for internal package docs covering all submodules.\n\n\n\n\nContents\n\n\n\n\nPublic Documentation\n\n\nContents\n\n\nIndex\n\n\nAbstractBlockArray interface\n\n\nBlockArray\n\n\nPseudoBlockArray\n\n\n\n\n\n\n\n\n\n\nIndex\n\n\n\n\nBase.full\n\n\nBase.getindex\n\n\nBase.setindex!\n\n\nBlockArrays.AbstractBlockArray\n\n\nBlockArrays.Block\n\n\nBlockArrays.BlockArray\n\n\nBlockArrays.BlockBoundsError\n\n\nBlockArrays.PseudoBlockArray\n\n\nBlockArrays.blockcheckbounds\n\n\nBlockArrays.blocksize\n\n\nBlockArrays.getblock\n\n\nBlockArrays.getblock!\n\n\nBlockArrays.nblocks\n\n\nBlockArrays.setblock!\n\n\n\n\n\n\nAbstractBlockArray interface\n\n\nThis sections defines the functions a subtype of \nAbstractBlockArray\n should define to be a part of the \nAbstractBlockArray\n interface. An \nAbstractBlockArray{T, N}\n is a subtype of \nAbstractArray{T,N}\n and should therefore also fulfill the \nAbstractArray\n interface\n.\n\n\n#\n\n\nBlockArrays.AbstractBlockArray\n \n \nType\n.\n\n\nabstract AbstractBlockArray{T, N} \n: AbstractArray{T, N}\n\n\n\n\nThe abstract type that represents a blocked array. Types that implement the \nAbstractBlockArray\n interface should subtype from this type.\n\n\n Typealiases \n\n\n\n\n\n\nAbstractBlockMatrix{T}\n -\n \nAbstractBlockArray{T, 2}\n\n\n\n\n\n\nAbstractBlockVector{T}\n -\n \nAbstractBlockArray{T, 1}\n\n\n\n\n\n\nAbstractBlockVecOrMat{T}\n -\n \nUnion{AbstractBlockMatrix{T}, AbstractBlockVector{T}}\n\n\n\n\n\n\nsource\n\n\n#\n\n\nBlockArrays.BlockBoundsError\n \n \nType\n.\n\n\nBlockBoundsError([A],[inds...])\n\n\n\n\nThrown when a block indexing operation into a block array, \nA\n, tried to access an out-of-bounds block, \ninds\n.\n\n\nsource\n\n\n#\n\n\nBlockArrays.Block\n \n \nType\n.\n\n\nBlock(inds...)\n\n\n\n\nA \nBlock\n is simply a wrapper around a set of indices or enums so that it can be used to dispatch on. By indexing a \nAbstractBlockArray\n with a \nBlock\n the a block at that block index will be returned instead of a single element.\n\n\njulia\n A = BlockArray(rand(2,3), [1,1], [2,1])\n2\u00d72-blocked 2\u00d73 BlockArrays.BlockArray{Float64,2,Array{Float64,2}}:\n 0.190705  0.798036  \u2502  0.471299\n --------------------\u253c-----------\n 0.770005  0.845003  \u2502  0.0315575\n\njulia\n A[Block(1,2)]\n1\u00d71 Array{Float64,2}:\n 0.471299\n\n\n\n\nsource\n\n\n#\n\n\nBlockArrays.nblocks\n \n \nFunction\n.\n\n\nnblocks(A, [dim...])\n\n\n\n\nReturns a tuple containing the number of blocks in a block array.  Optionally you can specify the dimension(s) you want the number of blocks for.\n\n\njulia\n A =  BlockArray(rand(5,4,6), [1,4], [1,2,1], [1,2,2,1]);\n\njulia\n nblocks(A)\n(2,3,4)\n\njulia\n nblocks(A, 2)\n3\n\njulia\n nblocks(A, 3, 2)\n(4,3)\n\n\n\n\nsource\n\n\n#\n\n\nBlockArrays.blocksize\n \n \nFunction\n.\n\n\nblocksize(A, inds...)\n\n\n\n\nReturns a tuple containing the size of the block at block index \ninds...\n.\n\n\njulia\n A = BlockArray(rand(5,4,6), [1,4], [1,2,1], [1,2,2,1]);\n\njulia\n blocksize(A,1,3,2)\n(1,1,2)\n\njulia\n blocksize(A,2,1,3)\n(4,1,2)\n\n\n\n\nsource\n\n\n#\n\n\nBlockArrays.getblock\n \n \nFunction\n.\n\n\ngetblock(A, inds...)\n\n\n\n\nReturns the block at blockindex \ninds...\n. An alternative syntax is \nA[Block(inds...)]. Throws a\nBlockBoundsError` if this block is out of bounds.\n\n\njulia\n A = BlockArray(rand(2,3), [1,1], [2,1])\n2\u00d72-blocked 2\u00d73 BlockArrays.BlockArray{Float64,2,Array{Float64,2}}:\n 0.190705  0.798036  \u2502  0.471299\n --------------------\u253c-----------\n 0.770005  0.845003  \u2502  0.0315575\n\njulia\n getblock(A, 2, 1)\n1\u00d72 Array{Float64,2}:\n 0.770005  0.845003\n\njulia\n A[Block(1,2)]\n1\u00d71 Array{Float64,2}:\n 0.471299\n\n\n\n\nsource\n\n\n#\n\n\nBlockArrays.getblock!\n \n \nFunction\n.\n\n\ngetblock!(X, A, inds...)\n\n\n\n\nStores the block at blockindex \ninds\n in \nX\n and returns it. Throws a \nBlockBoundsError\n if the attempted assigned block is out of bounds.\n\n\njulia\n A = PseudoBlockArray(rand(2,3), [1,1], [2,1])\n2\u00d72-blocked 2\u00d73 BlockArrays.PseudoBlockArray{Float64,2,Array{Float64,2}}:\n 0.2062    0.0238446  \u2502  0.0505515\n ---------------------\u253c-----------\n 0.744768  0.225364   \u2502  0.23028\n\njulia\n x = zeros(1,2);\n\njulia\n getblock!(x, A, 2, 1);\n\njulia\n x\n1\u00d72 Array{Float64,2}:\n 0.744768  0.225364\n\n\n\n\nsource\n\n\n#\n\n\nBlockArrays.setblock!\n \n \nFunction\n.\n\n\nsetblock!(A, v, inds...)\n\n\n\n\nStores the block \nv\n in the block at block index \ninds\n in \nA\n. An alternative syntax is \nA[Block(inds...)] = v\n. Throws a \nBlockBoundsError\n if this block is out of bounds.\n\n\njulia\n A = PseudoBlockArray(zeros(2,3), [1,1], [2,1]);\n\njulia\n setblock!(A, [1 2], 1,1);\n\njulia\n A[Block(2,1)] = [3 4];\n\njulia\n A\n2\u00d72-blocked 2\u00d73 BlockArrays.PseudoBlockArray{Float64,2,Array{Float64,2}}:\n 1.0  2.0  \u2502  0.0\n ----------\u253c-----\n 3.0  4.0  \u2502  0.0\n\n\n\n\nsource\n\n\n#\n\n\nBase.getindex\n \n \nFunction\n.\n\n\ngetindex{T, N}(A::AbstractBlockArray{T,N}, i...::Enum)\n\n\n\n\nReturns the block at the blockindex defined by the values of the enums \ni\n\n\njulia\n A = PseudoBlockArray(zeros(2,3), [1,1], [2,1]);\n\njulia\n @enum vars u = 1 v = 2\n\njulia\n A[Block(1,2)] = [3.0];\n\nulia\n A[u, v]\n1\u00d71 Array{Float64,2}:\n 3.0\n\n\n\n\nsource\n\n\n#\n\n\nBase.setindex!\n \n \nFunction\n.\n\n\nsetindex!{T, N}(A::AbstractBlockArray{T,N}, v, i...::Enum)\n\n\n\n\nSets the block at the blockindex defined by the values of the enums \ni\n\n\njulia\n A = PseudoBlockArray(zeros(2,3), [1,1], [2,1]);\n\njulia\n @enum vars u = 1 v = 2\n\njulia\n A[u,v] = [3.0];\n\njulia\n A\n2\u00d72-blocked 2\u00d73 BlockArrays.PseudoBlockArray{Float64,2,Array{Float64,2}}:\n 0.0  0.0  \u2502  3.0\n ----------\u253c-----\n 0.0  0.0  \u2502  0.0\n\n\n\n\nsource\n\n\n#\n\n\nBase.full\n \n \nFunction\n.\n\n\nfull(A)\n\n\n\n\nReturns the full array stored in \nA\n. Full is here not used in the sense of sparse vs dense but in blocked vs unblocked.\n\n\njulia\n A = BlockArray(rand(2,3), [1,1], [2,1])\n2\u00d72-blocked 2\u00d73 BlockArrays.BlockArray{Float64,2,Array{Float64,2}}:\n 0.770528  0.396896  \u2502  0.443308\n --------------------\u253c----------\n 0.857069  0.403512  \u2502  0.915934\n\njulia\n full(A)\n2\u00d73 Array{Float64,2}:\n 0.770528  0.396896  0.443308\n 0.857069  0.403512  0.915934\n\n\n\n\nsource\n\n\n#\n\n\nBlockArrays.blockcheckbounds\n \n \nFunction\n.\n\n\nblockcheckbounds(A, inds...)\n\n\n\n\nThrow a \nBlockBoundsError\n if the specified block indexes are not in bounds for the given block array. Subtypes of \nAbstractBlockArray\n should specialize this method if they need to provide custom block bounds checking behaviors.\n\n\njulia\n A = BlockArray(rand(2,3), [1,1], [2,1]);\n\njulia\n blockcheckbounds(A, 3,2)\nERROR: BlockBoundsError: attempt to access 2\u00d72-blocked 2\u00d73 BlockArrays.BlockArray{Float64,2,Array{Float64,2}} at block index [3,2]\n in blockcheckbounds(::BlockArrays.BlockArray{Float64,2,Array{Float64,2}}, ::Int64, ::Int64)\n in eval(::Module, ::Any) at ./boot.jl:226\n\n\n\n\nsource\n\n\n\n\nBlockArray\n\n\n#\n\n\nBlockArrays.BlockArray\n \n \nType\n.\n\n\nBlockArray{T, N, R} \n: AbstractBlockArray{T, N}\n\n\n\n\nA \nBlockArray\n is an array where each block is stored contiguously. This means that insertions and retrival of blocks can be very fast since no copying of data is needed.\n\n\nIn the type definition, \nR\n defines the array type that each block has, for example `Matrix{Float64}.\n\n\nsource\n\n\nConstructs a \nBlockArray\n with uninitialized blocks from a block type.\n\n\nsource\n\n\n\n\nPseudoBlockArray\n\n\n#\n\n\nBlockArrays.PseudoBlockArray\n \n \nType\n.\n\n\nPseudoBlockArray{T, N, R} \n: AbstractBlockArray{T, N}\n\n\n\n\nA \nPseudoBlockArray\n is similar to a \nBlockArray\n except the full array is stored contiguously instead of block by block. This means that is not possible to insert and retrieve blocks without copying data. On the other hand \nfull\n on a \nPseudoBlockArray\n is instead instant since it just returns the wrapped array.\n\n\nWhen iteratively solving a set of equations with a gradient method the Jacobian typically has a block structure. It can be convenient to use a \nPseudoBlockArray\n to build up the Jacobian block by block and then pass the resulting matrix to a direct solver using \nfull\n.\n\n\njulia\n A = PseudoBlockArray(rand(2,3), [1,1], [2,1])\n2\u00d72-blocked 2\u00d73 BlockArrays.PseudoBlockArray{Float64,2,Array{Float64,2}}:\n 0.599925  0.288788  \u2502  0.55428\n --------------------\u253c----------\n 0.82342   0.394812  \u2502  0.263454\n\njulia\n A = PseudoBlockArray(sprand(6, 0.5), [3,2,1])\n3-blocked 6-element BlockArrays.PseudoBlockArray{Float64,1,SparseVector{Float64,Int64}}:\n 0.542401\n 0.542299\n 0.0\n ---------\n 0.682638\n 0.0\n ---------\n 0.0553841\n\n\n\n\nsource", 
            "title": "Public"
        }, 
        {
            "location": "/lib/public/#public-documentation", 
            "text": "Documentation for  BlockArrays.jl 's public interface.  See  Internal Documentation  for internal package docs covering all submodules.", 
            "title": "Public Documentation"
        }, 
        {
            "location": "/lib/public/#contents", 
            "text": "Public Documentation  Contents  Index  AbstractBlockArray interface  BlockArray  PseudoBlockArray", 
            "title": "Contents"
        }, 
        {
            "location": "/lib/public/#index", 
            "text": "Base.full  Base.getindex  Base.setindex!  BlockArrays.AbstractBlockArray  BlockArrays.Block  BlockArrays.BlockArray  BlockArrays.BlockBoundsError  BlockArrays.PseudoBlockArray  BlockArrays.blockcheckbounds  BlockArrays.blocksize  BlockArrays.getblock  BlockArrays.getblock!  BlockArrays.nblocks  BlockArrays.setblock!", 
            "title": "Index"
        }, 
        {
            "location": "/lib/public/#abstractblockarray-interface", 
            "text": "This sections defines the functions a subtype of  AbstractBlockArray  should define to be a part of the  AbstractBlockArray  interface. An  AbstractBlockArray{T, N}  is a subtype of  AbstractArray{T,N}  and should therefore also fulfill the  AbstractArray  interface .  #  BlockArrays.AbstractBlockArray     Type .  abstract AbstractBlockArray{T, N}  : AbstractArray{T, N}  The abstract type that represents a blocked array. Types that implement the  AbstractBlockArray  interface should subtype from this type.   Typealiases     AbstractBlockMatrix{T}  -   AbstractBlockArray{T, 2}    AbstractBlockVector{T}  -   AbstractBlockArray{T, 1}    AbstractBlockVecOrMat{T}  -   Union{AbstractBlockMatrix{T}, AbstractBlockVector{T}}    source  #  BlockArrays.BlockBoundsError     Type .  BlockBoundsError([A],[inds...])  Thrown when a block indexing operation into a block array,  A , tried to access an out-of-bounds block,  inds .  source  #  BlockArrays.Block     Type .  Block(inds...)  A  Block  is simply a wrapper around a set of indices or enums so that it can be used to dispatch on. By indexing a  AbstractBlockArray  with a  Block  the a block at that block index will be returned instead of a single element.  julia  A = BlockArray(rand(2,3), [1,1], [2,1])\n2\u00d72-blocked 2\u00d73 BlockArrays.BlockArray{Float64,2,Array{Float64,2}}:\n 0.190705  0.798036  \u2502  0.471299\n --------------------\u253c-----------\n 0.770005  0.845003  \u2502  0.0315575\n\njulia  A[Block(1,2)]\n1\u00d71 Array{Float64,2}:\n 0.471299  source  #  BlockArrays.nblocks     Function .  nblocks(A, [dim...])  Returns a tuple containing the number of blocks in a block array.  Optionally you can specify the dimension(s) you want the number of blocks for.  julia  A =  BlockArray(rand(5,4,6), [1,4], [1,2,1], [1,2,2,1]);\n\njulia  nblocks(A)\n(2,3,4)\n\njulia  nblocks(A, 2)\n3\n\njulia  nblocks(A, 3, 2)\n(4,3)  source  #  BlockArrays.blocksize     Function .  blocksize(A, inds...)  Returns a tuple containing the size of the block at block index  inds... .  julia  A = BlockArray(rand(5,4,6), [1,4], [1,2,1], [1,2,2,1]);\n\njulia  blocksize(A,1,3,2)\n(1,1,2)\n\njulia  blocksize(A,2,1,3)\n(4,1,2)  source  #  BlockArrays.getblock     Function .  getblock(A, inds...)  Returns the block at blockindex  inds... . An alternative syntax is  A[Block(inds...)]. Throws a BlockBoundsError` if this block is out of bounds.  julia  A = BlockArray(rand(2,3), [1,1], [2,1])\n2\u00d72-blocked 2\u00d73 BlockArrays.BlockArray{Float64,2,Array{Float64,2}}:\n 0.190705  0.798036  \u2502  0.471299\n --------------------\u253c-----------\n 0.770005  0.845003  \u2502  0.0315575\n\njulia  getblock(A, 2, 1)\n1\u00d72 Array{Float64,2}:\n 0.770005  0.845003\n\njulia  A[Block(1,2)]\n1\u00d71 Array{Float64,2}:\n 0.471299  source  #  BlockArrays.getblock!     Function .  getblock!(X, A, inds...)  Stores the block at blockindex  inds  in  X  and returns it. Throws a  BlockBoundsError  if the attempted assigned block is out of bounds.  julia  A = PseudoBlockArray(rand(2,3), [1,1], [2,1])\n2\u00d72-blocked 2\u00d73 BlockArrays.PseudoBlockArray{Float64,2,Array{Float64,2}}:\n 0.2062    0.0238446  \u2502  0.0505515\n ---------------------\u253c-----------\n 0.744768  0.225364   \u2502  0.23028\n\njulia  x = zeros(1,2);\n\njulia  getblock!(x, A, 2, 1);\n\njulia  x\n1\u00d72 Array{Float64,2}:\n 0.744768  0.225364  source  #  BlockArrays.setblock!     Function .  setblock!(A, v, inds...)  Stores the block  v  in the block at block index  inds  in  A . An alternative syntax is  A[Block(inds...)] = v . Throws a  BlockBoundsError  if this block is out of bounds.  julia  A = PseudoBlockArray(zeros(2,3), [1,1], [2,1]);\n\njulia  setblock!(A, [1 2], 1,1);\n\njulia  A[Block(2,1)] = [3 4];\n\njulia  A\n2\u00d72-blocked 2\u00d73 BlockArrays.PseudoBlockArray{Float64,2,Array{Float64,2}}:\n 1.0  2.0  \u2502  0.0\n ----------\u253c-----\n 3.0  4.0  \u2502  0.0  source  #  Base.getindex     Function .  getindex{T, N}(A::AbstractBlockArray{T,N}, i...::Enum)  Returns the block at the blockindex defined by the values of the enums  i  julia  A = PseudoBlockArray(zeros(2,3), [1,1], [2,1]);\n\njulia  @enum vars u = 1 v = 2\n\njulia  A[Block(1,2)] = [3.0];\n\nulia  A[u, v]\n1\u00d71 Array{Float64,2}:\n 3.0  source  #  Base.setindex!     Function .  setindex!{T, N}(A::AbstractBlockArray{T,N}, v, i...::Enum)  Sets the block at the blockindex defined by the values of the enums  i  julia  A = PseudoBlockArray(zeros(2,3), [1,1], [2,1]);\n\njulia  @enum vars u = 1 v = 2\n\njulia  A[u,v] = [3.0];\n\njulia  A\n2\u00d72-blocked 2\u00d73 BlockArrays.PseudoBlockArray{Float64,2,Array{Float64,2}}:\n 0.0  0.0  \u2502  3.0\n ----------\u253c-----\n 0.0  0.0  \u2502  0.0  source  #  Base.full     Function .  full(A)  Returns the full array stored in  A . Full is here not used in the sense of sparse vs dense but in blocked vs unblocked.  julia  A = BlockArray(rand(2,3), [1,1], [2,1])\n2\u00d72-blocked 2\u00d73 BlockArrays.BlockArray{Float64,2,Array{Float64,2}}:\n 0.770528  0.396896  \u2502  0.443308\n --------------------\u253c----------\n 0.857069  0.403512  \u2502  0.915934\n\njulia  full(A)\n2\u00d73 Array{Float64,2}:\n 0.770528  0.396896  0.443308\n 0.857069  0.403512  0.915934  source  #  BlockArrays.blockcheckbounds     Function .  blockcheckbounds(A, inds...)  Throw a  BlockBoundsError  if the specified block indexes are not in bounds for the given block array. Subtypes of  AbstractBlockArray  should specialize this method if they need to provide custom block bounds checking behaviors.  julia  A = BlockArray(rand(2,3), [1,1], [2,1]);\n\njulia  blockcheckbounds(A, 3,2)\nERROR: BlockBoundsError: attempt to access 2\u00d72-blocked 2\u00d73 BlockArrays.BlockArray{Float64,2,Array{Float64,2}} at block index [3,2]\n in blockcheckbounds(::BlockArrays.BlockArray{Float64,2,Array{Float64,2}}, ::Int64, ::Int64)\n in eval(::Module, ::Any) at ./boot.jl:226  source", 
            "title": "AbstractBlockArray interface"
        }, 
        {
            "location": "/lib/public/#blockarray", 
            "text": "#  BlockArrays.BlockArray     Type .  BlockArray{T, N, R}  : AbstractBlockArray{T, N}  A  BlockArray  is an array where each block is stored contiguously. This means that insertions and retrival of blocks can be very fast since no copying of data is needed.  In the type definition,  R  defines the array type that each block has, for example `Matrix{Float64}.  source  Constructs a  BlockArray  with uninitialized blocks from a block type.  source", 
            "title": "BlockArray"
        }, 
        {
            "location": "/lib/public/#pseudoblockarray", 
            "text": "#  BlockArrays.PseudoBlockArray     Type .  PseudoBlockArray{T, N, R}  : AbstractBlockArray{T, N}  A  PseudoBlockArray  is similar to a  BlockArray  except the full array is stored contiguously instead of block by block. This means that is not possible to insert and retrieve blocks without copying data. On the other hand  full  on a  PseudoBlockArray  is instead instant since it just returns the wrapped array.  When iteratively solving a set of equations with a gradient method the Jacobian typically has a block structure. It can be convenient to use a  PseudoBlockArray  to build up the Jacobian block by block and then pass the resulting matrix to a direct solver using  full .  julia  A = PseudoBlockArray(rand(2,3), [1,1], [2,1])\n2\u00d72-blocked 2\u00d73 BlockArrays.PseudoBlockArray{Float64,2,Array{Float64,2}}:\n 0.599925  0.288788  \u2502  0.55428\n --------------------\u253c----------\n 0.82342   0.394812  \u2502  0.263454\n\njulia  A = PseudoBlockArray(sprand(6, 0.5), [3,2,1])\n3-blocked 6-element BlockArrays.PseudoBlockArray{Float64,1,SparseVector{Float64,Int64}}:\n 0.542401\n 0.542299\n 0.0\n ---------\n 0.682638\n 0.0\n ---------\n 0.0553841  source", 
            "title": "PseudoBlockArray"
        }, 
        {
            "location": "/lib/internals/", 
            "text": "Internal Documentation\n\n\n\n\nContents\n\n\n\n\nInternal Documentation\n\n\nContents\n\n\nIndex\n\n\nInternals\n\n\n\n\n\n\n\n\n\n\nIndex\n\n\n\n\nBlockArrays.BlockIndex\n\n\nBlockArrays.blockindex2global\n\n\nBlockArrays.global2blockindex\n\n\n\n\n\n\nInternals\n\n\n#\n\n\nBlockArrays.BlockIndex\n \n \nType\n.\n\n\nBlockIndex{N}\n\n\n\n\nA \nBlockIndex\n is an index which stores a global index in two parts: the block and the offset index into the block.\n\n\nsource\n\n\n#\n\n\nBlockArrays.blockindex2global\n \n \nFunction\n.\n\n\nblockindex2global{N}(block_sizes::BlockSizes{N}, block_index::BlockIndex{N}) -\n inds\n\n\n\n\nConverts from a block index to a tuple containing the global indices\n\n\nsource\n\n\n#\n\n\nBlockArrays.global2blockindex\n \n \nFunction\n.\n\n\nglobal2blockindex{N}(block_sizes::BlockSizes{N}, inds...) -\n BlockIndex{N}\n\n\n\n\nConverts from global indices \ninds\n to a \nBlockIndex\n.\n\n\nsource", 
            "title": "Internals"
        }, 
        {
            "location": "/lib/internals/#internal-documentation", 
            "text": "", 
            "title": "Internal Documentation"
        }, 
        {
            "location": "/lib/internals/#contents", 
            "text": "Internal Documentation  Contents  Index  Internals", 
            "title": "Contents"
        }, 
        {
            "location": "/lib/internals/#index", 
            "text": "BlockArrays.BlockIndex  BlockArrays.blockindex2global  BlockArrays.global2blockindex", 
            "title": "Index"
        }, 
        {
            "location": "/lib/internals/#internals", 
            "text": "#  BlockArrays.BlockIndex     Type .  BlockIndex{N}  A  BlockIndex  is an index which stores a global index in two parts: the block and the offset index into the block.  source  #  BlockArrays.blockindex2global     Function .  blockindex2global{N}(block_sizes::BlockSizes{N}, block_index::BlockIndex{N}) -  inds  Converts from a block index to a tuple containing the global indices  source  #  BlockArrays.global2blockindex     Function .  global2blockindex{N}(block_sizes::BlockSizes{N}, inds...) -  BlockIndex{N}  Converts from global indices  inds  to a  BlockIndex .  source", 
            "title": "Internals"
        }
    ]
}